7.4: 磁盘管理-挂载
2014年11月24日
22:46
 
磁盘挂载
=================================================================
命令：mount
作用：挂载文件系统
语法：
mount [参数] 分区 挂载目录
mount [参数] UUID='' 挂载目录 (推荐方式)
mount -a
mount -l
挂载原则：
单一分区不要重复挂载到不同目录
单一目录不要重复挂载不同分区
挂载目录理论上需要是空目录
参数：
-t 指定分区格式，如果分区格式不匹配则报错
-a 按照/etc/fstab里面的配置，将没有挂载上来的文件系统全部挂载
-o（选项可以放在/etc/fstab里的挂载选项里）
async/sync 非同步写入还是同步写入
(async原理：当资料从硬盘载入到内存中后，假设该资料未改变，状态为clean，若资料在内存中改变，则内存中标记该资料为dirty，async挂载时系统会不定时的将dirty的资料写入到硬盘中，保证资料在内存与硬盘中同步)
auto\noauto 是否可被"mount -a"自动挂载
dev\nodev 在此分区上是否允许建立设备档案
remount 重新挂载
ro "read-only"以只读模式挂载
usrquota\grquota 用户\分组的磁盘配额，随着目前大硬件的普及，越来越少用到
default（rw suid exec auto nouser async dev）
用法举例：
## 挂载xfs格式的sdb3，默认是读写模式
# mount -t xfs /dev/sdb3 /mnt/m1
# mount -l | grep xfs
/dev/sdb3 on /mnt/m1 type xfs (rw)
 
## 重新以只读模式挂载sdb3
# mount -o remount,ro -t xfs /dev/sdb3 /mnt/m1
# mount -l | grep xfs
/dev/sdb3 on /mnt/m1 type xfs (ro)
 
## 挂载光盘
# mkdir /data/cdrom
# mount /dev/sr0 /data/cdrom
 
## 挂载光盘镜像
# mount -o loop /data/iso/CentOS-7-x86_64-DVD-1503-01.iso /mnt
# mount -l |grep CentOS
/data/iso/CentOS-7-x86_64-DVD-1503-01.iso on /mnt type iso9660 (ro,relatime) [CentOS 7 x86_64]
 
 
## 挂载vfat格式的U盘(centos7上测试)
# blkid | grep vfat
/dev/sdd1: LABEL="MY_DRIVE" TYPE="vfat"
# mkdir /mnt/usb
# mount -o codepage=950,iocharset=utf8 /dev/sdd1 /mnt/usb
# mount -l | grep sdd1
/dev/sdd1 on /mnt/usb type vfat (rw,relatime,fmask=0022,dmask=0022,codepage=950,iocharset=utf8,shortname=mixed,errors=remount-ro) [MY_DRIVE]
 
## 挂载NTFS格式的硬盘
## 工具ntfs-3g可以挂载ntfs格式 
奇葩挂载研究：
1、挂载时如果处于挂载目录，需要退出此目录一次，才可以查看到挂载分区的内容
# pwd ; ls
/mnt/ss
ss.txt
# mount /dev/sdb1 /mnt/ss
# ls 
ss.txt
# cd ..
# ls ./ss
lost+found  test1  test2             
## ss.txt只是被隐藏，umount掉sdb1以后，就会恢复 
2、可以将分区挂载到不同的目录，但不推荐
# mount /dev/sdb1 /mnt/m1
# mount /dev/sdb1 /mnt/m2
# mount|grep sdb1
/dev/sdb1 on /mnt/m1 type ext4 (rw)
/dev/sdb1 on /mnt/m2 type ext4 (rw) 
3、多个分区可同时挂载到同一个目录，仅供满足个人好奇心，强烈不推荐，且没有任何意义
## 同时挂载sdb1和sdb2到ss1目录
# mount /dev/sdb2 /mnt/ss1
# mount /dev/sdb1 /mnt/ss1
# mount | grep /mnt/ss1
/dev/sdb2 on /mnt/ss1 type ext4 (rw)
/dev/sdb1 on /mnt/ss1 type ext4 (rw)
 
## 通过目录内容推测最后挂载的sdb1目前生效
# ls /mnt/ss1
lost+found  test1  test2
 
## 创建新文件lor2，以供接下来的测试
# touch /mnt/ss1/1or2
 
## 相继卸载掉sdb1和sdb2，重新单独挂载sdb1，检查lor2文件
# umount /dev/sdb1
# umount /dev/sdb2
# mount /dev/sdb1 /mnt/ss1
# ls /mnt/ss1
1or2  lost+found  test1  test2
 
## 按照与上次相反的顺序，即先挂sdb1后挂sdb2的方式
## 发现是否生效与挂载顺序有关
# mount /dev/sdb2 /mnt/ss1
# ls /mnt/ss1
lost+found
 
## 卸载顺序需要与挂载顺序相反，否则会报错
# umount /dev/sdb1
umount: cannot umount /dev/sdb1 -- \
/dev/sdb2 is mounted over it on the same point.
# umount /dev/sdb2
# umount /dev/sdb1
总结：
若两个文件系统挂载到同一个目录下，后挂载的文件系统生效
卸载的顺序和挂载的顺序必须相反，即只能先卸载挂载生效的分区。
最后，这样挂载毫无意义，强烈不推荐这样操作 
bind模式挂载
# mount --bind /etc /mnt/m1
[root@localhost ~]# ll /mnt/m1/passwd
-rw-r--r--. 1 root root 934 Apr 28 00:35 /mnt/m1/passwd
# mount -l |grep /etc
/etc on /mnt/m1 type none (rw,bind) 
 
命令：umount
作用：卸载文件系统
语法：
umount 文件系统名称
umount 挂载点
参数:
-l lazy模式，立即卸载设备，在文件系统不繁忙的时候清除所有的索引
用法举例：
## xfs格式的sdb3挂载到了/mnt/m1上
# mount -l | grep xfs
/dev/sdb3 on /mnt/m1 type xfs (ro)
 
## 进入到挂载目录下，常规卸载报错
# cd /mnt/m1
# umount /mnt/m1
umount: /mnt/m1: device is busy.
        (In some cases useful info about processes that use
         the device is found by lsof(8) or fuser(1))
 
## 用lazy模式卸载
# umount -l /mnt/m1
# mount -l |grep /mnt/m1 
 
 
挂载相关文件
=============================================================
配置文件：/etc/filesystems
配置内容：记录了当前系统支持的磁盘格式
文件内容：
# cat /etc/filesystems
ext4
ext3
ext2
nodev proc
nodev devpts
iso9660
vfat
hfs
hfsplusPS：
此配置文件中不支持的文件格式可通过其他特殊工具来支持，例如工具ntfs-3g可以挂载ntfs格式
 
 
配置文件：/etc/fstab
配置内容：开机挂载的文件系统和"mount -a"参考的如何挂载文件系统都写在这里
文件内容：
# cat /etc/fstab
 
#
# /etc/fstab
# Created by anaconda on Wed Jan 13 05:53:59 2016
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
UUID=f354fcc9-2144-4b51-b55b-0727570e2450 /                       ext4    defaults        1 1
UUID=619a84a7-7fb2-4ad0-9d8d-5860d14610a1 /boot                   ext4    defaults        1 2
UUID=864ecee1-bb51-42f8-bb77-4ec3f86e09b0 /data                   ext4    defaults        1 2
UUID=2022d4bf-6e4a-4e94-a67b-112389296afa swap                    swap    defaults        0 0
tmpfs                   /dev/shm                tmpfs   defaults        0 0
devpts                  /dev/pts                devpts  gid=5,mode=620  0 0
sysfs                   /sys                    sysfs   defaults        0 0
proc                    /proc                   proc    defaults        0 0
 
## 每一段的含义如下
"设备/uuid"  "挂载点"  "格式"  "挂载选项"  "dump"  "fsck"
## 其中
dump：1可备份，0相反
fsck：开机检测级别，0不检测，剩下的数字越小优先级越高，也就是说，先检测1，然后是2
 
## mount option
## 用','来分隔多个选项
noatime - 挂载时不用update普通文件的atime
nodiratime - 挂载时不用update目录的atime
 
扩展：https://wiki.archlinux.org/index.php/fstab
